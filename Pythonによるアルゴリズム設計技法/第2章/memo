第2章 アルゴリズム解析の基礎

計算機における重要な考え
無限に長いテープ上を動きながら読み書きのみができるマシン＝チューリングマシン
アルゴリズムの効率をより詳細に分析する場合はランダムアクセスマシン
ランダムアクセスマシンは以下の特徴を持つ
・マシンは並列実行できず指令を1つずつ実行する
・算術演算、比較、メモリアクセスなど標準的な基本演算はすべて定数時間がかかる。
・マシン内の1ワードは無限大ではないが変数が使うメモリもふくめ
　解いている問題を表現するのにつかわれるすべてのメモリの場所を指定できるほど大きい。
問題＝入力と出力の関係

漸近記法
漸近記法は19世紀後半から使われているアルゴリズムとデータ構造の分析に必須なツール。
入力サイズをパラメータとして分析するリソースを関数で表すこと。
漸近記法はギリシャ文字で書かれたたくさんの演算子で成り立っている。
最も重要なものはΟ（ビッグオー）、Ω（オメガ）、Θ（シータ）の3つ。
Ο演算子の定義はほかの2つの文字の土台となる。
Οはある関数g(n)に対するΟ(g)という表現は関数の集合を示す。
以下の条件を満たす場合ｍ関数f(n)がこの集合内にあることとなる。
条件：自然数n0と正の定数cが存在しn≧n0を満たすすべてのnに対してf(n)≦cg(n)が成り立つ
そのためΟはおおよその限界を示すのに使える。
ΩはΟと逆。以下の条件を満たすときに関数fが集合Ω(g)に属している
条件：自然数n0と正の定数cが存在しn≧n0を満たすすべてのnについてf(n)≧cg(n)が成り立つ
つまりΟが漸近的上限だとするとΩは漸近的下限となる。
Θで表される集合は単純に2つの集合の共通集合。つまりΘ(g) = Ο(g)∩Ω(g)
以下の条件を満たす場合、関数fはΘ(g)に属している。
条件：自然数n0と2つの正の定数c1およびc2が存在しn≧n0を満たすすべてのnについてc1g(n)≦f(n)≦c2g(n)が成り立つ

交通ルール
以下は漸近的実行時間、計算量の名前、代表的なアルゴリズム
Θ(1)：定数時間：ハッシュテーブルのアクセスと修正
Θ(logn)：対数時間：二分探索
Θ(n)：線形時間：リスト上の走査
Θ(nlogn)：線形対数時間：任意の値の最適なソート
Θ(n^2)：二乗時間：n個のオブジェクト同士を互いに比較
Θ(n^3)：三乗時間：Floyd-Warshallアルゴリズム
Θ(n^k)：多項式時間：定数kを正の整数としてforループがk乗の入れ子のとき
Ω(k^n)：指数時間：k>1においてn個の要素からすべての組み合わせを作る処理
Θ(n!)：階乗時間：n個の値すべての順序を作る処理
任意の多項式時間のアルゴリズムは任意の対数時間のアルゴリズムより支配的で
任意の指数時間のアルゴリズムは任意の多項式時間より支配的。

漸近法の試し乗り
初めに問題のインスタンスの細かな条件には影響を受けず問題のサイズにのみ依存している
プログラムについて考える。
ループがない場合、単純。1行実行しまた次の1行を実行する。そのたびに計算量が足されていく。
例えば大きさnのリストに対してappendするのはΘ(1)←線形時間
以下のプログラムを考える
>>> nums.append(1)→定数時間がかかる。
>>> nums.insert(0,2)→リストのサイズが変わりΘ(n+1)となる
s = 0
for x in seq:
    s += x
この場合、定数時間（s += x）をseqのn個の要素に対して行うので線形時間Θ(n)となる。
以下のリスト内包表記も線形時間
squares = [x**2 for in seq]
ループを入れ子構造にすると少し複雑になる。
s = 0
for x in seq:
    for y in seq:
        s += x*y
この場合の計算量は1行ずつコードブロックを実行し計算量を足していくだけ。
入れ子構造の場合はかけ合わせて計算する。
理由として外側のループの間に内側のループが1回ずつ実行される。
その場合、線形時間×線形時間なので2乗時間となる。
入れ子が増えれば3乗、4乗と増えていく

3つの大事なケース
入力の条件を細かく指定して以下3つの重要なケースに分けることで実行時間の予測を行う。
・最良のケース
→入力がアルゴリズムにとって最適な場合に得られる実行時間
・最悪のケース
→想定される最悪の条件での実行時間
・平均的なケース
→ランダムな入力に対し確率分布を考え計算した実行時間
多くの場合は3つは同じ結果となる。
そうでない場合、最悪な場合を使う。

実験的にアルゴリズムを計算するコツは以下
・出来る限り心配しない
・時間測定はtimeitを利用する
・ボトルネックを見つけるためにプロファイラーを使う
・結果を可視化する
・時間の比較によって結論を導き出すときは要注意
・実験によって漸近性について結論を出すときは要注意

グラフと木構造の実装
グラフ問題として問題が定式化できているのであれば半分は解けたようなもの
問題が木構造として表現できるのであれば非常に効率的な解法が見つかる可能性が高い
グラフ用語の簡単なまとめは以下
・グラフ：G=(V,E)はノードVとその間のエッジEの集合から構成。エッジに方向がある場合有向グラフという。
・ノードの間にエッジに方向があるものは隣接しているという。
　そのエッジは2つのノードに接続しているという。あるノードνに隣接しているノードはνの近傍という。
　ノードの次数とはそのノードに接続しているエッジの数。
・G=(V,E)の部分グラフは部分集合Vと部分集合Eから構成されている。Gにおける道とは同じノードをたどらず
　連続したノードがエッジによってつながっている部分グラフのこと。サイクルは道に似ているが
　最後のエッジが最初と最後のノードを結んでいる点が違う
・Gの各エッジに重みづけをすることでGは重みづきグラフと呼ばれる。
　道やサイクルの長さは各エッジの重みの合計で表される。
・森はサイクルの含んでいないグラフを指し連結している森は木となる。
問題をグラフ用語で表現することで問題を解決することに近づくが、解法を実装したい場合そのグラフを
何らかのデータ構造として表現する必要がある。

隣接リスト
グラフを最も直感的に実装する方法は隣接リストを使うこと
基本的には各ノードに対し近傍のリストを作る。
各ノードに対し番号を振るとあるノードに対する隣接ノードのリストは単なる数字のリストとなる。
その隣接ノードリストはサイズnのメインリストに入れることでノード番号でインデックス化される。
通常これらのリストの順序は任意なので実際にはリストを使って隣接セットを実装する。

隣接行列
グラフ表現で他に一般的なのは隣接行列。
各ノードに対して全ての近傍をリストアップする代わりに各近傍の候補に対して1つの値を持つ行（配列）を作る。
そこには各ノードが実際に近傍であるかどうかを示すbool値が保存されている。

木構造の実装
木はグラフの少し特殊な形に過ぎないので木構造は一般的なグラフ表現でも表すことはできる。
ただし木はアルゴリズムの重要な役割を担うので特別な目的をもった木構造が多く提案される。
木構造アルゴリズムを理解することは特殊な木構造を考慮することでより簡単となる。
もっとも簡単な方法は根から各エッジがすべて下に向いている根付き木の表現を特殊化するやり方。
このような木はよくデータの階層的なパーティションの表現としてよく使われる。
根はすべてのオブジェクトを代表する一方、各内部ノードはそのノードを根としたときの葉に当たるオブジェクトを代表とする。
ノードに子が1つしかない場合、欠落している子をNoneなどを使って表現する。

ブラックボックスにご注意を
アルゴリズムを設計する場合、抽象的なレベルで作業をするが
実際にアルゴリズムを実装するときは自分で書いていないコンポーネントを
理解せず使うのは危険。